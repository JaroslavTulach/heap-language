package com.oracle.truffle.gradle;

import org.gradle.api.Plugin;
import org.gradle.api.Project;
import org.gradle.api.artifacts.Configuration;
import org.gradle.api.plugins.ApplicationPluginConvention;
import org.gradle.api.plugins.JavaBasePlugin;
import org.gradle.api.tasks.Copy;
import org.gradle.jvm.application.tasks.CreateStartScripts;
import org.gradle.process.JavaForkOptions;

import javax.annotation.Nonnull;
import java.io.File;
import java.io.IOException;
import java.util.Map;

/**
 * <p>Graal compiler plugin enhances the project so that Graal compiler can be used even on non-Graal JVMs.
 * The version of compiler used can be configured using a {@code graal { graalVersion = "version_string" } }
 * block inside the {@code build.gradle} script.</p>
 *
 * <p>The plugin automatically adds a dependency on the Graal compiler, downloads it to a separate folder,
 * and performs two modifications to ensure the compiler is available in code generated by this project:</p>
 *
 * <p>First, any task that implements {@code JavaForkOptions} (e.g. {@code test}, {@code run}, or any {@code JavaExec}
 * task) has its {@code jvmArgs} extended to enable the Graal compiler on Hotspot (if the running JVM is
 * incompatible with the compiler, a warning is printed).</p>
 *
 * <p>Second, any distribution will also include a separate {@code compiler} directory with the graal compiler
 * and the {@code DEFAULT_JVM_OPTS} in all start scripts are modified to initialize the compiler from this
 * directory. (you can disable this behaviour by setting {@code graal { bundleGraal = false } }).</p>
 */
public class GraalCompilerPlugin implements Plugin<Project> {

    @Override
    public void apply(@Nonnull Project project) {
        project.getPluginManager().apply(JavaBasePlugin.class);
        GraalExtension config = GraalExtension.initInProject(project);

        // Create a graalCompiler configuration which will hold the actual Graal compiler dependencies.
        Configuration graalCompiler = project.getConfigurations().create("graalCompiler")
                .setVisible(false)
                .setDescription("Graal compiler and its dependencies.");
        graalCompiler.setCanBeResolved(true);

        // Lazily add dependency on the graal compiler to the configuration.
        graalCompiler.withDependencies(dependencies ->
            dependencies.add(project.getDependencies().create("org.graalvm.compiler:compiler:"+config.getGraalVersion()))
        );

        // Create the prepareCompiler task which will be used to copy the graal compiler files.
        Copy prepareCompiler = project.getTasks().create("prepareCompiler", Copy.class, task -> task.setGroup("graal"));

        // And configure the task (this has to be done after evaluate because config is not initialized yet).
        project.afterEvaluate(it -> {
            prepareCompiler.from(graalCompiler.getFiles());
            prepareCompiler.into(config.graalCompilerDir);
        });

        // Make all JavaForkOptions tasks use the compiler (and depend on prepareCompiler).
        project.getTasks().all(task -> {
            if (task instanceof JavaForkOptions) {
                task.dependsOn(prepareCompiler);
                task.doFirst(it -> {
                    if (!PluginUtils.isGraalVM()) { // enable compiler only on non-Graal VMs
                        if (!PluginUtils.hasJVMCI()) {  // incompatible JVM - print warning and ignore
                            System.err.println("WARNING: Support for JVM Compiler Interface not detected.");
                            System.err.println("Truffle languages running in interpreter mode only.");
                        } else {
                            JavaForkOptions opts = (JavaForkOptions) it;
                            opts.jvmArgs(
                                    "-XX:+UnlockExperimentalVMOptions", "-XX:+EnableJVMCI",
                                    "--module-path="+config.graalCompilerDir.getAbsolutePath(),
                                    "--upgrade-module-path="+config.graalCompilerDir.getAbsolutePath()
                            );
                        }
                    }
                });
            }
        });

        // Make sure all distributions also include graal compiler.
        // It has to be done after evaluate, because to configure a distribution, we need to resolve `graalCompiler`
        // config and check `bundleGraal`.
        project.afterEvaluate(p -> {
            if (!config.bundleGraal) return; // Only configure if not disabled

            // Add graal compiler to a separate folder in each distribution.
            PluginUtils.withDistributions(project, distributions -> distributions.all(dist -> {
                dist.getContents().from(graalCompiler.getFiles(), spec -> spec.into("graalCompiler"));
            }));

            // In all CreateStartScripts tasks, replace occurrences of __APP_HOME__ with appropriate environment variable.
            // (This is also used in other plugins that depend on us, but it is defined only once - here)
            project.getTasks()
                    .withType(CreateStartScripts.class)
                    .all(GraalCompilerPlugin::addReplaceAppHomeAction);

            // Add default JVM arguments to the start scripts which will enable the Graal compiler.
            project.getTasks()
                    .withType(CreateStartScripts.class)
                    .all(GraalCompilerPlugin::addCompilerArgsToDistribution);
        });

        // If application plugin is applied, also create a distNative task that will
        // generate native image binary for the application.
        project.afterEvaluate(p -> {
            Map<String, Object> plugins = project.getConvention().getPlugins();
            if (plugins.containsKey("application")) {
                Object applicationConvention = plugins.get("application");
                if (!(applicationConvention instanceof ApplicationPluginConvention)) {
                    System.err.println("Cannot automatically create distNative task.");
                    System.err.println("Expected ApplicationPluginConvention, but found "+applicationConvention+".");
                } else {
                    ApplicationPluginConvention app = (ApplicationPluginConvention) applicationConvention;
                    project.getTasks().create("distNative", NativeImage.class, task -> {
                        task.setForMainClass(app.getMainClassName());
                        task.setOutputName(app.getApplicationName());
                        task.setOutputDir(new File(p.getBuildDir(), "distributions"));
                    });
                }
            }
        });

    }

    private static void addReplaceAppHomeAction(CreateStartScripts scripts) {
        scripts.doLast(it -> {
            try {
                PluginUtils.replaceInFile(scripts.getUnixScript(), "__APP_HOME__", "$APP_HOME");
                PluginUtils.replaceInFile(scripts.getWindowsScript(), "__APP_HOME__", "%APP_HOME%");
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        });
    }

    private static void addCompilerArgsToDistribution(CreateStartScripts scripts) {
        scripts.doFirst(it ->
            scripts.setDefaultJvmOpts(PluginUtils.appendIterable(scripts.getDefaultJvmOpts(),
                    "-XX:+IgnoreUnrecognizedVMOptions", // A workaround so that we don't have to remove graal compiler on older JVMs.
                    "-XX:+UnlockExperimentalVMOptions",
                    "-XX:+EnableJVMCI",
                    "--module-path=__APP_HOME__/graalCompiler/",
                    "--upgrade-module-path=__APP_HOME__/graalCompiler/"
            ))
        );
    }

}
